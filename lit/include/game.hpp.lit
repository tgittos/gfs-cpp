== Game class header ==
This header file gives a broad overview of the features
of the game class.

The first thing to note is that this is a static class.
This is due to the need for a single interface to the
game used in the bootstrapping process.

== State enumeration ==
Pang is a state driven game, meaning that the game can
only be in a single state at a given time, with the
available states in the enumeration.
-
enum GameState { 
  Uninitialized, 
  ShowingSplash, 
  Paused, 
  ShowingMenu, 
  Playing, 
  Exiting 
};
-

== Game state variable ==
For Pang to be state driven, we need to be able to hold
the current state of the app
-
static GameState _gameState;
-

== Window reference variable ==
In addition to the game state variable, we need to hold
a reference to the SFML window
-
static sf::RenderWindow _mainWindow;
-

== Game object manager variable ==
We need to store a reference to all of the objects we
create in the game.
-
static GameObjectManager _gameObjectManager;
-

== Start game method ==
To that end, there is only a single public method, used
to start the game. The game itself will handle all
interactions after that, and all memory management.
-
static void Start();
-

== Get window ==
The get window method gets the render window off of the
game.

This method introduces two kinds of paradigms of
messaging, and couples whatever method calls into
this method tightly with the game. This is not great.
I would rather stick with injecting windows where we
need them rather than pulling them off of a global
game object.

Chalk this another method to refactor away
-
static sf::RenderWindow& GetWindow();
-

== Get input ==
Like the get window method, this introduces coupling
between a game object and the game.

Refactor this away too.
-
const static sf::Input& GetInput();
-

== Get object manager ==
Like the get window and get input, this introduces
coupling.

Refactor away.
-
static GameObjectManager& GetGameObjectManager();
-

== Public constants ==
Screen width and height, public so that we can pull it
for game logic. Maybe needs to be decoupled too.

Try and refactor this away, though it may be pretty hard.
We don't want to pass in 5 params to each method.
Maybe a game settings object, especially if you want to be
able to resize the window.
-
const static int SCREEN_WIDTH = 1024;
const static int SCREEN_HEIGHT = 768;
-

== Exit poller method ==
This method is used inside the class to determine if the
app has been called to shut down.
-
static bool IsExiting();
-

== Show splash screen method ==
-
static void ShowSplashScreen();
-

== Show menu method ==
-
static void ShowMenu();
-

== Game loop method ==
Start the game loop.
-
static void GameLoop();
-

== The class header ==
-
class Game
{

public:
  Public constants.
  
  Start game method.
  Get window.
  Get input.
  Get object manager.

private:
  State enumeration.
  
  Game state variable.
  Window reference variable.
  Game object manager variable.

  Exit poller method.
  Game loop method.
  Show splash screen method.
  Show menu method.

};
-

== Includes ==
So far all the application does is open a window and
clear it to a red color. So all we need are the window
and graphics SFML libraries.
-
#include "SFML/Window.hpp"
#include "SFML/Graphics.hpp"
#include <cassert>
#include "gameobjectmanager.hpp"
-

== Include guard ==
-
#ifndef GAME_H
#define GAME_H

Includes.

The class header.

#endif
-

== @game.hpp ==
Include guard.